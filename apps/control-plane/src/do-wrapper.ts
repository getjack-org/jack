/**
 * Generates the __jack_do_meter.mjs wrapper module that instruments
 * Durable Object classes with Analytics Engine metering.
 *
 * Uses inheritance (not composition) to preserve the Agents SDK class chain.
 */

const JS_IDENTIFIER_RE = /^[A-Za-z_$][A-Za-z0-9_$]*$/;

export function generateDoWrapper(options: {
	classNames: string[];
	originalModule: string;
	projectId: string;
	orgId: string;
}): string {
	const { classNames, originalModule, projectId, orgId } = options;

	if (!classNames || classNames.length === 0) {
		throw new Error("classNames must contain at least one class name");
	}

	if (!originalModule) {
		throw new Error("originalModule must not be empty");
	}

	for (const name of classNames) {
		if (!JS_IDENTIFIER_RE.test(name)) {
			throw new Error(
				`Invalid class name "${name}": must be a valid JavaScript identifier (alphanumeric, underscore, or $, not starting with a digit)`,
			);
		}
	}

	const imports = classNames.map((n) => `${n} as __Orig_${n}`).join(", ");
	const wraps = classNames.map((n) => `const ${n} = wrapDO(__Orig_${n}, "${n}");`).join("\n");
	const exports = classNames.join(", ");

	return `// __jack_do_meter.mjs â€” generated by jack control plane
import { ${imports} } from "./${originalModule}";

const PROJECT_ID = "${projectId}";
const ORG_ID = "${orgId}";

function wrapDO(Original, className) {
  return class extends Original {
    async fetch(request) {
      const start = Date.now();
      try {
        return await super.fetch(request);
      } finally {
        this.env?.__JACK_USAGE?.writeDataPoint({
          indexes: [PROJECT_ID],
          blobs: [ORG_ID, className, "fetch"],
          doubles: [Date.now() - start, 1],
        });
      }
    }

    async alarm() {
      const start = Date.now();
      try {
        return await super.alarm?.();
      } finally {
        this.env?.__JACK_USAGE?.writeDataPoint({
          indexes: [PROJECT_ID],
          blobs: [ORG_ID, className, "alarm"],
          doubles: [Date.now() - start, 1],
        });
      }
    }

    async webSocketMessage(ws, message) {
      const start = Date.now();
      try {
        return await super.webSocketMessage?.(ws, message);
      } finally {
        this.env?.__JACK_USAGE?.writeDataPoint({
          indexes: [PROJECT_ID],
          blobs: [ORG_ID, className, "webSocketMessage"],
          doubles: [Date.now() - start, 1],
        });
      }
    }

    async webSocketClose(ws, code, reason, wasClean) {
      const start = Date.now();
      try {
        return await super.webSocketClose?.(ws, code, reason, wasClean);
      } finally {
        this.env?.__JACK_USAGE?.writeDataPoint({
          indexes: [PROJECT_ID],
          blobs: [ORG_ID, className, "webSocketClose"],
          doubles: [Date.now() - start, 1],
        });
      }
    }

    async webSocketError(ws, error) {
      const start = Date.now();
      try {
        return await super.webSocketError?.(ws, error);
      } finally {
        this.env?.__JACK_USAGE?.writeDataPoint({
          indexes: [PROJECT_ID],
          blobs: [ORG_ID, className, "webSocketError"],
          doubles: [Date.now() - start, 1],
        });
      }
    }
  };
}

${wraps}
export { ${exports} };

// Re-export the Worker entrypoint unchanged
export { default } from "./${originalModule}";
`;
}
