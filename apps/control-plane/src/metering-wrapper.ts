/**
 * Generates the __jack_meter.mjs wrapper module that instruments
 * Durable Object classes and/or Vectorize bindings with Analytics Engine metering.
 *
 * DO wrapping uses inheritance (not composition) to preserve the Agents SDK class chain.
 * Vectorize wrapping uses a Proxy to intercept method calls on the binding.
 */

const JS_IDENTIFIER_RE = /^[A-Za-z_$][A-Za-z0-9_$]*$/;

export function generateMeteringWrapper(options: {
	originalModule: string;
	projectId: string;
	orgId: string;
	doClassNames?: string[];
	vectorizeBindings?: Array<{ bindingName: string; indexName: string }>;
}): string {
	const { originalModule, projectId, orgId, doClassNames, vectorizeBindings } =
		options;

	if (!originalModule) {
		throw new Error("originalModule must not be empty");
	}

	const hasDO = doClassNames && doClassNames.length > 0;
	const hasVectorize = vectorizeBindings && vectorizeBindings.length > 0;

	if (!hasDO && !hasVectorize) {
		throw new Error("At least one of doClassNames or vectorizeBindings must be provided");
	}

	// Validate DO class names
	if (doClassNames && doClassNames.length === 0) {
		throw new Error("doClassNames must contain at least one class name when provided");
	}

	if (hasDO) {
		for (const name of doClassNames) {
			if (!JS_IDENTIFIER_RE.test(name)) {
				throw new Error(
					`Invalid class name "${name}": must be a valid JavaScript identifier (alphanumeric, underscore, or $, not starting with a digit)`,
				);
			}
		}
	}

	const lines: string[] = [];

	lines.push("// __jack_meter.mjs — generated by jack control plane");

	// --- Imports ---

	if (hasDO) {
		const imports = doClassNames
			.map((n) => `${n} as __Orig_${n}`)
			.join(", ");
		lines.push(`import { ${imports} } from "./${originalModule}";`);
	}

	if (hasVectorize) {
		// Import default export for wrapping
		lines.push(`import __OrigWorker from "./${originalModule}";`);
	}

	lines.push("");
	lines.push(`const PROJECT_ID = "${projectId}";`);
	lines.push(`const ORG_ID = "${orgId}";`);

	// --- DO wrapping ---

	if (hasDO) {
		lines.push("");
		lines.push(`function wrapDO(Original, className) {
  return class extends Original {
    async fetch(request) {
      const start = Date.now();
      try {
        return await super.fetch(request);
      } finally {
        this.env?.__JACK_USAGE?.writeDataPoint({
          indexes: [PROJECT_ID],
          blobs: [ORG_ID, className, "fetch"],
          doubles: [Date.now() - start, 1],
        });
      }
    }

    async alarm() {
      const start = Date.now();
      try {
        return await super.alarm?.();
      } finally {
        this.env?.__JACK_USAGE?.writeDataPoint({
          indexes: [PROJECT_ID],
          blobs: [ORG_ID, className, "alarm"],
          doubles: [Date.now() - start, 1],
        });
      }
    }

    async webSocketMessage(ws, message) {
      const start = Date.now();
      try {
        return await super.webSocketMessage?.(ws, message);
      } finally {
        this.env?.__JACK_USAGE?.writeDataPoint({
          indexes: [PROJECT_ID],
          blobs: [ORG_ID, className, "webSocketMessage"],
          doubles: [Date.now() - start, 1],
        });
      }
    }

    async webSocketClose(ws, code, reason, wasClean) {
      const start = Date.now();
      try {
        return await super.webSocketClose?.(ws, code, reason, wasClean);
      } finally {
        this.env?.__JACK_USAGE?.writeDataPoint({
          indexes: [PROJECT_ID],
          blobs: [ORG_ID, className, "webSocketClose"],
          doubles: [Date.now() - start, 1],
        });
      }
    }

    async webSocketError(ws, error) {
      const start = Date.now();
      try {
        return await super.webSocketError?.(ws, error);
      } finally {
        this.env?.__JACK_USAGE?.writeDataPoint({
          indexes: [PROJECT_ID],
          blobs: [ORG_ID, className, "webSocketError"],
          doubles: [Date.now() - start, 1],
        });
      }
    }
  };
}`);

		lines.push("");
		lines.push(
			doClassNames
				.map((n) => `const ${n} = wrapDO(__Orig_${n}, "${n}");`)
				.join("\n"),
		);
		lines.push(`export { ${doClassNames.join(", ")} };`);
	}

	// --- Vectorize wrapping ---

	if (hasVectorize) {
		lines.push("");
		lines.push(`function wrapVectorize(vec, ae, indexName) {
  const countable = new Set(["upsert", "insert", "deleteByIds", "getByIds"]);
  return new Proxy(vec, {
    get(target, prop, receiver) {
      const val = Reflect.get(target, prop, receiver);
      if (typeof val !== "function") return val;
      return async function (...args) {
        const start = Date.now();
        try {
          return await val.apply(target, args);
        } finally {
          ae.writeDataPoint({
            indexes: [PROJECT_ID],
            blobs: [ORG_ID, "free", "vectorize", indexName, String(prop)],
            doubles: [1, Date.now() - start, countable.has(prop) ? (args[0]?.length ?? 0) : 0, 0],
          });
        }
      };
    },
  });
}`);
	}

	// --- Default export ---

	lines.push("");

	if (hasVectorize) {
		// Build the env wrapping logic for each vectorize binding
		const envOverrides = vectorizeBindings
			.map((b) => {
				return `    if (env.${b.bindingName} && env.__JACK_VECTORIZE_USAGE) {\n      env = { ...env, ${b.bindingName}: wrapVectorize(env.${b.bindingName}, env.__JACK_VECTORIZE_USAGE, "${b.indexName}") };\n    }`;
			})
			.join("\n");

		// Use Proxy on the default export to wrap env in ALL handler methods
		// (fetch, scheduled, queue, email, tail — all take env as 2nd arg).
		// This prevents metering bypass via non-fetch handlers (e.g. cron + vectorize).
		lines.push(`function __wrapEnv(env) {
${envOverrides}
  return env;
}

export default new Proxy(__OrigWorker, {
  get(target, prop) {
    const handler = target[prop];
    if (typeof handler !== "function") return handler;
    return function (arg1, env, ...rest) {
      return handler.call(target, arg1, __wrapEnv(env), ...rest);
    };
  },
});`);
	} else {
		// No vectorize — re-export the Worker entrypoint unchanged
		lines.push(
			`// Re-export the Worker entrypoint unchanged\nexport { default } from "./${originalModule}";`,
		);
	}

	lines.push("");

	return lines.join("\n");
}
