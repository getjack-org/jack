/**
 * Client-side encryption for secrets sent to the control plane.
 *
 * Uses hybrid RSA-OAEP + AES-GCM so secrets of any size can be encrypted.
 * The control plane holds the matching RSA private key as a worker secret.
 */

export interface EncryptedEnvelope {
	__encrypted: true;
	kid: string;
	wrappedKey: string; // base64url
	iv: string; // base64url
	ciphertext: string; // base64url
}

const KEY_ID = "v1";

/** RSA-OAEP-256 public key for secrets encryption (generated by scripts/generate-encryption-keypair.ts) */
const PUBLIC_KEY_JWK: JsonWebKey = {
	alg: "RSA-OAEP-256",
	e: "AQAB",
	ext: true,
	key_ops: ["encrypt"],
	kty: "RSA",
	n: "lwfWlWFQBpMOHv7NNn7XQO_egRNsc8Pkhj-ZugE_nmProyIUfBcDQPXl_iFDqpxpRVs28pSDMdnj9btnE59Y2rA4H0lENxjtVVc5mTFKzHSnsrVWKFU4m6GE2mz9_8_WOcpg6F3GJqYaD5nYagRsj8ph9O0qx4Z84rfM4NxSST61xasc6TVEbTABSY3jZHCn4NqerwAWcTaccJ75MwYfnhF28zBrq4yoBf7vhCxhxxYw1PdnixjFqbia36KK8IN5CzMsY9zILTGAAD4gTLs8XVeWiJ6r_y_by8OGPkmRSUuAzdh3VPMn0GqreXIpB6mwi3YrSVehI6b0j7t1cdm17VHh2cXMFJh78r4cX6ogMjc8AZ6CqX3d93-P5s7usxDLnaG10Xx_9X4RnLFDbBRLvgFmW9WLj2UkX-RNiVUhpbc23iO5kDT4v9z2DkylQ9hfx2tD7WcVQf8ff_go41ynPe3gHKKMIggUdkzGF9JPb0jdM_aRj3E0RECDkNt5i3UQD8rPtWX8orX9CQ0PgNuY5dtfL2mGROquRkqm5WysrT1OqVxHsns1jcaCnMVpsOVjIbMPhvGGoOEiUL6wvnfmbvW0ql-tOcX34SgL9UtqdbbFYsj2RAOfggj4Trps3s8Kej2fAvTZEAZlSJKyT_Yd8PiaRcUGomLwcPmBSZwRDWk",
};

function base64urlEncode(bytes: ArrayBuffer | Uint8Array): string {
	const u8 = bytes instanceof Uint8Array ? bytes : new Uint8Array(bytes);
	let bin = "";
	for (let i = 0; i < u8.length; i++) {
		bin += String.fromCharCode(u8[i]);
	}
	return btoa(bin).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}

let _cachedPublicKey: CryptoKey | null = null;

async function getPublicKey(): Promise<CryptoKey> {
	if (_cachedPublicKey) return _cachedPublicKey;
	_cachedPublicKey = await crypto.subtle.importKey(
		"jwk",
		PUBLIC_KEY_JWK,
		{ name: "RSA-OAEP", hash: "SHA-256" },
		false,
		["encrypt"],
	);
	return _cachedPublicKey;
}

/** Encrypt a single plaintext string into an encrypted envelope. */
export async function encryptSecretValue(plaintext: string): Promise<EncryptedEnvelope> {
	const rsaKey = await getPublicKey();

	// Generate ephemeral AES-256-GCM key
	const aesKey = await crypto.subtle.generateKey({ name: "AES-GCM", length: 256 }, true, [
		"encrypt",
	]);

	// Encrypt plaintext with AES-GCM
	const iv = crypto.getRandomValues(new Uint8Array(12));
	const plainBytes = new TextEncoder().encode(plaintext);
	const ciphertext = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, aesKey, plainBytes);

	// Wrap the AES key with RSA-OAEP
	const rawAesKey = await crypto.subtle.exportKey("raw", aesKey);
	const wrappedKey = await crypto.subtle.encrypt({ name: "RSA-OAEP" }, rsaKey, rawAesKey);

	return {
		__encrypted: true,
		kid: KEY_ID,
		wrappedKey: base64urlEncode(wrappedKey),
		iv: base64urlEncode(iv),
		ciphertext: base64urlEncode(ciphertext),
	};
}

/**
 * Encrypt a full secrets map (Record<string, string>) as a single envelope.
 * The entire JSON object is serialized then encrypted as one blob.
 */
export async function encryptSecrets(secrets: Record<string, string>): Promise<EncryptedEnvelope> {
	return encryptSecretValue(JSON.stringify(secrets));
}
